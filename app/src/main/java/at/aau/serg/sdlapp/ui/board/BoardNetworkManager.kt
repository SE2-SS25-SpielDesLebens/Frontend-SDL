package at.aau.serg.sdlapp.ui.board

import android.content.Context
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.widget.Toast
import at.aau.serg.sdlapp.model.board.Field
import at.aau.serg.sdlapp.model.player.PlayerManager
import at.aau.serg.sdlapp.network.StompConnectionManager
import at.aau.serg.sdlapp.network.message.MoveMessage
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.hildan.krossbow.stomp.subscribeText
import java.util.Timer
import java.util.TimerTask
import at.aau.serg.sdlapp.network.viewModels.*

/**
 * Verwaltet die Netzwerkkommunikation der BoardActivity
 */
class BoardNetworkManager(
    private val context: Context,
    private val playerManager: PlayerManager,
    private val playerName: String,
    private val playerId: String,
    private val callbacks: NetworkCallbacks,
    private val lobbyId: String? = null,
    private val stompClient: StompConnectionManager// Optional: Lobby-ID f√ºr Mehrspieler
) {
    // STOMP-Client f√ºr die Verbindung zum Backend

    
    // Timer f√ºr die periodische Aktualisierung der Spielerliste
    private var playerListUpdateTimer: Timer? = null
    
    init {
        initializeCallbacks()
        
        // Wenn eine Lobby-ID vorhanden ist, sofort verbinden
        if (!lobbyId.isNullOrEmpty()) {
            println("üé≤ BoardNetworkManager: Verbinde mit Lobby $lobbyId")
            
            // Eine kleine Verz√∂gerung, um sicherzustellen, dass UI initialisiert ist
            Handler(Looper.getMainLooper()).postDelayed({
                joinExistingGame(lobbyId)
            }, 500)
        }
    }    /**
     * Initialisiert alle Callbacks f√ºr den STOMP-Client
     */
    private fun initializeCallbacks() {
        // Handler f√ºr die Liste der aktiven Spieler
        stompClient.onPlayerListReceived = { playerIds ->
            Handler(Looper.getMainLooper()).post {
                println("üë• Liste der aktiven Spieler erhalten: $playerIds")

                // √úbergebe Spielerliste an Callback-Methode
                callbacks.onPlayerListReceived(playerIds)
            }
        }
        
        // Handler f√ºr Farb√§nderungen von Spielern
        stompClient.onPlayerColorChanged = { playerId, colorName ->
            Handler(Looper.getMainLooper()).post {
                println("üé® Farb√§nderung f√ºr Spieler $playerId: $colorName")
                
                // Aktualisiere die Spielerfarbe im PlayerManager
                playerManager.updatePlayerColor(playerId, colorName)
                
                // √úbergebe Farbwechsel an Callback-Methode
                callbacks.onPlayerColorChanged(playerId, colorName)
            }
        }

        // Verbindungsstatus √ºberwachen
        stompClient.onConnectionStateChanged = { isConnected ->
            Handler(Looper.getMainLooper()).post {
                callbacks.onConnectionStateChanged(isConnected)
                
                if (isConnected) {
                    // Nach einer erfolgreichen Verbindung fragen wir nach allen aktiven Spielern
                    requestActivePlayers()
                    println("üë• Frage nach aktiven Spielern...")

                    // Starte den Timer f√ºr periodische Aktualisierungen der Spielerliste
                    startPlayerListUpdateTimer()
                } else {
                    // Timer stoppen wenn die Verbindung verloren geht
                    stopPlayerListUpdateTimer()
                }
            }
        }

        // Behandlung von Verbindungsfehlern
        stompClient.onConnectionError = { errorMessage ->
            Handler(Looper.getMainLooper()).post {
                // In einer vollst√§ndigen Implementierung w√ºrde ein Dialog angezeigt werden
                println("üî¥ Verbindungsfehler: $errorMessage")
                callbacks.onConnectionError(errorMessage)
            }
        }

        // Bewegung per Backend-Daten
        stompClient.onMoveReceived = { move ->
            Handler(Looper.getMainLooper()).post {
                try {
                    // Verbesserte Logging f√ºr Debugging mit mehr Details
                    println("üì• MoveMessage empfangen: Feld=${move.fieldIndex}, Typ=${move.typeString}, " +
                            "Spieler=${move.playerName} (ID=${move.playerId}), N√§chste Felder=${move.nextPossibleFields.joinToString()}")

                    callbacks.onMoveReceived(move)
                } catch (e: Exception) {
                    println("‚ùå‚ùå‚ùå Unerwarteter Fehler bei der Bewegungsverarbeitung: ${e.message}")
                    e.printStackTrace()
                }
            }
        }

        // Handler f√ºr Board-Daten
        stompClient.onBoardDataReceived = { fields ->
            Handler(Looper.getMainLooper()).post {
                println("üìä Board-Daten vom Server erhalten (${fields.size} Felder)")
                callbacks.onBoardDataReceived(fields)
            }
        }
        
        // Handler f√ºr Spielerpositionen
        stompClient.onPlayerPositionsReceived = { positions ->
            Handler(Looper.getMainLooper()).post {
                println("üìç Spielerpositionen vom Server erhalten (${positions.size} Spieler)")
                callbacks.onPlayerPositionsReceived(positions)
            }
        }
    }

    /**
     * Sendet einen W√ºrfelwurf an das Backend
     */
    fun sendRealMove(diceRoll: Int, currentFieldIndex: Int) {
        stompClient.sendRealMove(playerName, diceRoll, currentFieldIndex)
    }

    /**
     * Sendet eine einfache Bewegung zu einem Feld
     */
    fun sendMove(message: String) {
        stompClient.sendMove(playerName, message)
    }

    /**
     * Fragt aktive Spieler vom Server ab
     */
    fun requestActivePlayers() {
        stompClient.requestActivePlayers(playerName)
    }    /**
     * Fordert die aktuellen Board-Daten vom Server an
     */
    fun requestBoardData() {
        try {
            println("üìä Fordere Board-Daten vom Server an")
            stompClient.sendMessage("/app/board/data", "{\"request\":\"getBoard\"}")
            
            // Nach kurzer Verz√∂gerung pr√ºfen, ob wir eine Antwort bekommen haben
            Handler(Looper.getMainLooper()).postDelayed({
                if (at.aau.serg.sdlapp.model.board.BoardData.board.isNotEmpty()) {
                    println("‚úÖ Board-Daten wurden geladen oder waren bereits verf√ºgbar")
                } else {
                    println("‚ö†Ô∏è Keine Board-Daten nach Anfrage erhalten")
                    // Zeige eine Warnung an
                    Toast.makeText(
                        context,
                        "Warnung: Keine Board-Daten vom Server erhalten",
                        Toast.LENGTH_SHORT
                    ).show()
                }
            }, 2000) // 2 Sekunden warten
            
        } catch (e: Exception) {
            println("‚ùå Fehler beim Anfordern der Board-Daten: ${e.message}")
            e.printStackTrace()
            
            // Fehler anzeigen
            Toast.makeText(
                context,
                "Fehler beim Anfordern der Brett-Daten",
                Toast.LENGTH_SHORT
            ).show()
        }
    }

    /**
     * Fordert die aktuellen Positionen aller Spieler vom Server an
     */
    fun requestPlayerPositions() {
        try {
            println("üìç Fordere Spielerpositionen vom Server an")
            stompClient.requestPlayerPositions()
        } catch (e: Exception) {
            println("‚ùå Fehler beim Anfordern der Spielerpositionen: ${e.message}")
            Toast.makeText(
                context,
                "Fehler beim Anfordern der Spielerpositionen",
                Toast.LENGTH_SHORT
            ).show()
        }
    }

    /**
     * Pr√ºft, ob die Verbindung besteht
     */
    val isConnected: Boolean
        get() = stompClient.isConnected
    
    /**
     * Gibt den STOMP-Client zur√ºck
     */
    fun getStompClient(): StompConnectionManager {
        return stompClient
    }

    /**
     * Startet einen Timer f√ºr periodische Aktualisierungen der Spielerliste
     */
    private fun startPlayerListUpdateTimer() {
        // Vorherigen Timer stoppen falls vorhanden
        playerListUpdateTimer?.cancel()

        // Neuen Timer erstellen
        playerListUpdateTimer = Timer()
        playerListUpdateTimer?.scheduleAtFixedRate(object : TimerTask() {
            override fun run() {
                // Anfrage nach Spielerliste senden
                requestActivePlayers()
                println("üîÑ Automatische Anfrage nach Spielerliste gesendet")
                
                // Auch Positionen aller Spieler aktualisieren
                requestPlayerPositions()
                println("üîÑ Automatische Anfrage nach Spielerpositionen gesendet")
            }
        }, 10000, 30000) // Initial nach 10 Sekunden, dann alle 30 Sekunden

        println("‚è∞ Spielerlisten-Update-Timer gestartet")
    }

    /**
     * Stoppt den Timer f√ºr die Spielerlisten-Aktualisierung
     */
    fun stopPlayerListUpdateTimer() {
        playerListUpdateTimer?.cancel()
        playerListUpdateTimer = null
        println("‚è∞ Spielerlisten-Update-Timer gestoppt")
    }    /**
     * Tritt einem bestehenden Spiel bei, das √ºber die Lobby-ID identifiziert wird
     */    /**
     * Tritt einem existierenden Spiel in einer Lobby bei
     */
    private fun joinExistingGame(lobbyId: String) {
        try {
            println("üéÆ Trete bestehendem Spiel in Lobby $lobbyId bei")
            
            // Stelle sicher, dass eine Verbindung besteht
            if (!stompClient.isConnected) {
                // Kurze Verz√∂gerung f√ºr die Verbindung
                Handler(Looper.getMainLooper()).postDelayed({
                    completeGameJoin(lobbyId)
                }, 1000)
            } else {
                Log.e("BoardNetworkManager", "Keine Verbindung m√∂glich")
                completeGameJoin(lobbyId)
            }
            
            Toast.makeText(
                context,
                "Trete Spiel in Lobby $lobbyId bei...",
                Toast.LENGTH_SHORT
            ).show()
            
        } catch (e: Exception) {
            println("‚ùå Fehler beim Beitreten des Spiels: ${e.message}")
            e.printStackTrace()
            
            Toast.makeText(
                context,
                "Fehler beim Beitreten des Spiels: ${e.message}",
                Toast.LENGTH_LONG
            ).show()
        }
    }
      /**
     * F√ºhrt den Spielbeitritt nach erfolgreicher Verbindung durch
     */
    private fun completeGameJoin(lobbyId: String) {
        // Starte den Spielbeitritt in einem Coroutine-Scope
        stompClient.run {
            scope.launch {
                try {
                    // 1. Lobby-Topic in separater Coroutine abonnieren, damit es nicht blockierend ist
                    scope.launch {
                        try {
                            sessionOrNull?.subscribeText("/topic/$lobbyId")?.collect { message ->
                                println("üì© Nachricht aus Lobby $lobbyId: $message")
                                // Je nach Inhalt verarbeiten (falls n√∂tig)
                            }
                        } catch (e: Exception) {
                            println("‚ùå Fehler beim Abonnieren des Lobby-Topics: ${e.message}")
                        }
                    }
                    println("‚úÖ Lobby-Topic abonniert: /topic/$lobbyId")
                    
                    // 2. Game-Status Topic in separater Coroutine abonnieren
                    scope.launch {
                        try {
                            sessionOrNull?.subscribeText("/topic/game/$lobbyId/status")?.collect { message ->
                                println("üì¢ Spielstatus: $message")
                            }
                        } catch (e: Exception) {
                            println("‚ùå Fehler beim Abonnieren des Status-Topics: ${e.message}")
                        }
                    }
                    println("‚úÖ Spiel-Status-Topic abonniert: /topic/game/$lobbyId/status")
                    
                    // 3. Spielbeitritt zum Server senden
                    joinExistingGame(lobbyId, playerName)
                    
                    // 4. Nach kurzer Verz√∂gerung Brettkonfiguration und Positionen anfordern
                    delay(1000)
                    requestBoardData()
                    requestPlayerPositions()
                    requestActivePlayers()
                } catch (e: Exception) {
                    println("‚ùå Fehler beim Spielbeitritt: ${e.message}")
                }
            }
        }
    }    /**
     * Interface f√ºr die Netzwerk-Callbacks
     */    interface NetworkCallbacks {
        fun onPlayerListReceived(playerIds: List<String>)
        fun onConnectionStateChanged(isConnected: Boolean)
        fun onConnectionError(errorMessage: String)
        fun onMoveReceived(move: MoveMessage)
        fun onPlayerColorChanged(playerId: String, colorName: String)

        /**
         * Wird aufgerufen, wenn Spiel-Brett-Daten vom Server empfangen wurden
         */
        fun onBoardDataReceived(fields: List<Field>)
        
        /**
         * Wird aufgerufen, wenn Spielerpositionen vom Server empfangen wurden
         */
        fun onPlayerPositionsReceived(positions: Map<String, Int>)
    }
}
